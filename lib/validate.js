// Generated by CoffeeScript 2.3.1
(function() {
  var Errors, _, messages, moment;

  messages = require('./message').error;

  _ = require('../node_modules/lodash/lodash.min.js');

  moment = require('../node_modules/moment/min/moment.min.js');

  Errors = class Errors {
    constructor(org) {
      this.add = this.add.bind(this);
      this.org = org;
      this.items = [];
      this.length = this.items.length;
    }

    add(item, messageNumber) {
      var message;
      message = messages[messageNumber];
      this.items.push({
        item: item,
        original: this.org.find(function(orgItem) {
          return moment(orgItem[0]).valueOf() === moment(item.Date).valueOf();
        }),
        level: message[0],
        errid: messageNumber,
        msg: message[2],
        msg_jp: message[1]
      });
      this.length = this.items.length;
      return this;
    }

    out(compact = true) {
      var items;
      if (compact) {
        items = _.groupBy(this.items, 'errid');
        items = Object.keys(items).map(function(id) {
          return items[id][0];
        });
      } else {
        items = this.items;
      }
      return items;
    }

  };

  module.exports = function(compact) {
    var err;
    err = new Errors(this.org);
    this.items.forEach(function(item, i) {
      var ref, ref1;
      // item.VolumeはParseFloatされているので値が不正でもNaNになる
      // つまり必ずNumberになる
      if (item.Volume < 0) {
        return err.add(item, 2);
      } else if (item.Volume > 0) {
        if (!item.Close) {
          return err.add(item, 5); // Volume is zero or NaN
        }
      } else {
        if (Number.isNaN(item.Open)) {
          return err.add(item, 3);
        } else if (!(((item.Close === (ref1 = item.High) && ref1 === (ref = item.Low)) && ref === item.Open))) {
          return err.add(item, 4);
        } else if (Number.isNaN(item.Volume)) {
          return err.add(item, 0);
        }
      }
    });
    return err.out(compact);
  };

}).call(this);
