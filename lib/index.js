// Generated by CoffeeScript 2.3.1
(function() {
  var OUTPUT_DATE_FORMAT, Ohlc, PROP_NAMES, _, calc, moment, objelity, util;

  _ = require('../node_modules/lodash/lodash.min.js');

  moment = require('../node_modules/moment/min/moment.min.js');

  objelity = require('objelity');

  calc = require('./calc');

  util = require('./util');

  OUTPUT_DATE_FORMAT = 'YYYY-MM-DD';

  PROP_NAMES = {
    inputDateFormat: 'inputDateFormat'
  };

  Ohlc = (function() {
    var _convertingPeriodBy, _parseNumber, momentOrThrow;

    class Ohlc {
      constructor(items, _opts) {
        if (_opts && _.isPlainObject(_opts)) {
          this.opts = objelity.mapObject(_opts, function(val, path) {
            if (/^inputDateFormat$/i.test(path)) {
              return [PROP_NAMES.inputDateFormat, val];
            } else {
              return [path, val];
            }
          });
        } else {
          this.opts = {};
        }
        if (_.isPlainObject(items)) {
          if (_.get(items, 'dataset.data', null)) {
            items = items.dataset.data;
          } else if (_.get(items, 'data', null)) {
            items = items.data;
          } else {
            throw new Error('inconsistent datatypes: expected Array got Object.');
          }
        }
        this.org = items;
        this.items = items.map((item) => {
          if (Array.isArray(item)) {
            return {
              "Date": momentOrThrow(item[0], this.opts).format(OUTPUT_DATE_FORMAT),
              // "Date": moment(item[0]).format(OUTPUT_DATE_FORMAT)
              Open: _parseNumber.call(this, item[1]),
              High: _parseNumber.call(this, item[2]),
              Low: _parseNumber.call(this, item[3]),
              Close: _parseNumber.call(this, item[4]),
              Volume: _parseNumber(item[5])
            };
          } else if (_.isPlainObject(item)) {
            return objelity.mapObject(item, (val, path) => {
              var _path, _val;
              _path = path;
              _val = _parseNumber(val);
              if (path.match(/date/i)) {
                _path = 'Date';
                _val = momentOrThrow(val, this.opts).format(OUTPUT_DATE_FORMAT);
              } else if (path.match(/open/i)) {
                _path = 'Open';
              } else if (path.match(/high/i)) {
                _path = 'High';
              } else if (path.match(/low/i)) {
                _path = 'Low';
              } else if (path.match(/close/i)) {
                _path = 'Close';
              } else if (path.match(/volume/i)) {
                _path = 'Volume';
              }
              return [_path, _val];
            });
          } else {
            throw new Error('inconsistent datatypes');
          }
        });
        this.items = _.sortBy(this.items, function(item) {
          return moment(item.Date).unix();
        });
        this.opts.round = (() => {
          var min;
          min = _.minBy(this.items, 'Low').Low;
          return util.decimalPlace(min);
        })();
        return;
      }

      validate(compact) {
        return require('./validate').call(this, compact);
      }

      modify() {
        return require('./modify').all.call(this);
      }

      round(num) {
        if (_.isNumber(num)) {
          if (Number.isNaN(num)) {
            return this;
          } else if (num <= 0) {
            this.opts.round = 0;
            return this;
          } else {
            this.opts.round = num;
            return this;
          }
        } else {
          return this;
        }
      }

      start(date) {
        this.opts.startDate = date;
        return this;
      }

      end(date) {
        this.opts.endDate = date;
        return this;
      }

      sma(...range) {
        this.opts.smas = range;
        return this;
      }

      vwma(...range) {
        this.opts.vwmas = range;
        return this;
      }

      toDaily() {
        return _convertingPeriodBy('', this.items, this.opts);
      }

      toWeekly() {
        return _convertingPeriodBy('weekly', this.items, this.opts);
      }

      toMonthly() {
        return _convertingPeriodBy('monthly', this.items, this.opts);
      }

      value(period) {
        return _convertingPeriodBy(period, this.items, this.opts);
      }

      toChartData(period) {
        var items, obj, otherItems;
        obj = {};
        items = _convertingPeriodBy(period, this.items, this.opts);
        obj.candle = items.map(function(item) {
          return [moment.utc(item.Date).valueOf(), item.Open, item.High, item.Low, item.Close];
        });
        obj.volume = items.map(function(item) {
          return [moment.utc(item.Date).valueOf(), item.Volume];
        });
        otherItems = _.difference(Object.keys(items[0]), ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']);
        otherItems.forEach(function(name) {
          return obj[name] = items.map(function(item) {
            return [moment.utc(item.Date).valueOf(), item[name]];
          });
        });
        return obj;
      }

    };

    _parseNumber = function(str) {
      if (_.isString(str)) {
        str = str.split(',').join('').trim();
      }
      return parseFloat(str);
    };

    momentOrThrow = function(date, opts) {
      var inputDateFormat, m;
      inputDateFormat = opts[PROP_NAMES.inputDateFormat];
      m = moment(date, inputDateFormat);
      if (m.isValid()) {
        return m;
      } else {
        throw new TypeError(`invalid date: ${date}`);
      }
    };

    _convertingPeriodBy = function(period, items, opts) {
      var end, groups, round, start;
      round = opts.round;
      items = (function() {
        switch (true) {
          case /^mo/.test(period):
            groups = _.groupBy(items, function(item) {
              return moment(item.Date).format('YYYY-MM');
            });
            return Object.keys(groups).map(function(_month) {
              var monthItems;
              monthItems = groups[_month];
              monthItems = _.sortBy(monthItems, function(item) {
                return moment(item.Date).unix();
              });
              return {
                "Date": moment(monthItems[0].Date).format('YYYY-MM-01'),
                Open: monthItems[0].Open,
                Close: _.last(monthItems).Close,
                High: _.maxBy(monthItems, 'High').High,
                Low: _.minBy(monthItems, 'Low').Low,
                Volume: calc.sumBy(monthItems, 'Volume')
              };
            });
          case /^we/.test(period):
            groups = _.groupBy(items, function(item) {
              return moment(item.Date).format('gggg-ww');
            });
            return Object.keys(groups).map(function(_week) {
              var _m, _weekDay, weekItems;
              weekItems = groups[_week];
              weekItems = _.sortBy(weekItems, function(item) {
                return moment(item.Date).unix();
              });
              _m = moment(weekItems[0].Date);
              _weekDay = _m.format('d');
              return {
                "Date": _m.subtract(_weekDay, 'days').format(OUTPUT_DATE_FORMAT),
                Open: weekItems[0].Open,
                Close: _.last(weekItems).Close,
                High: _.maxBy(weekItems, 'High').High,
                Low: _.minBy(weekItems, 'Low').Low,
                Volume: calc.sumBy(weekItems, 'Volume')
              };
            });
          default:
            return items;
        }
      })();
      if (opts.smas) {
        opts.smas.forEach(function(range) {
          return calc.addSma(range, items, opts.round);
        });
      }
      // calc.addSma(range,items,(val)->_.round(val,opts.round))
      if (opts.vwmas) {
        opts.vwmas.forEach(function(range) {
          return calc.addVwma(range, items, opts.round);
        });
      }
      // _addVwma(range,items,(val)->_.round(val,opts.round))
      if (opts.startDate || opts.endDate) {
        start = opts.startDate || items[0].Date;
        end = opts.endDate || _.last(items).Date;
        items = _.reject(items, function(item) {
          return moment(item.Date).isBefore(start) || moment(item.Date).isAfter(end);
        });
      }
      return items;
    };

    return Ohlc;

  }).call(this);

  module.exports = function(data, opts) {
    return new Ohlc(data, opts);
  };

}).call(this);
